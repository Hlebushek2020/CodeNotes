Flexlug — Сегодня, в 23:02
Значит ситуация какая...

DI - Dependency Injection.
Механизм, который очень сильно упрощает распределение зависимостей.
Простыми словами - если у тебя класс UserCommands требует другой класс (какой-нибудь DbProvider), то DI упростит доставку нужного тебе объекта до точки назначения.

Что нужно сделать, чтобы использовать DI?

Нужно создать ServiceCollection. Можешь создать его у себя в класcе YukoBot.
var services = new ServiceCollection();


Воспринимай это как коллекцию зависимостей. Причем важно понимать, что коллекция совершенно необязательно хранит сами инстансы. Эта коллекция может сама плодить инстансы (если к примеру для каждого командного модуля тебе нужен, к примеру, свой логер). 

Виды зависимостей:
Singleton - такая зависимость при вызове будет всегда поставляться в одном и том же экземпляре. Т.е. у всех модулей, которые её запросят, будут иметь ссылку на один и тот же объект.
Короче... принцип "один экземляр на весь ServiceCollection".
Scoped - будет создаваться только один экземпляр на один scope. Как правило такая штука используется редко
Transient - при каждом вызове зависимости будет создаваться новый экземпляр. 

Для каждого такого механизма определен свой метод расширения:
.AddSingleton<T>();
.AddScoped<T>();
.AddTransient<T>();


Также на какие-то специфические штуки существуют собственные методы расширения. К примеру через отдельный метод расширения в ServiceCollection можно запихать LoggerFactory:
.AddLogging()


После того, как ты собрал нужную тебе коллекцию, тебе нужно сбилдить коллекцию.
Таким образом финальный код будет иметь примерно следующий вид:
var services = new ServiceCollection()
  .AddLogging() // в зависимости от используемого логера конструкция может отличаться
  .AddSingleton<DbContext>()
  .BuildServiceProvider()


Таким образом ты создал лишь коллекцию. Этого ещё мало.
[23:09]
Далее уже идет работа с модулями, которые требуют зависимость.

Допустим...
У тебя есть модуль AdminCommands. И он требует зависимость DbContext. Также хотелось бы видеть логер специально для этого модуля (т.е. в логах будет отдельно помечаться, что сообщения исходят из конкретного модуля).
Что нужно сделать для того, чтобы зависимость попала в AdminCommands? Для начала укажем, что вообще модулю нужно.

Это делается через конструктор модуля.
public sealed class AdminCommands : BaseCommandModule
{
  private ILogger<AdminCommands> _logger;
  private DbContext _context;

  public AdminCommands(
    ILogger<AdminCommands> logger, // здесь самая главная магия
    DbContext context)
  {
    _logger = logger;
    _context = context;
  }
}


Теперь другой вопрос. Мы показали через конструктор, что хочет модуль. Откуда он будет это брать.
Благо DSharpPlus.CommandsNext можно ткнуть в твою ServiceCollection, чтобы дать ей понять, откуда брать зависимости.

Это делается следующим образом:
// Сбилженый ServiceCollection предоставляется экземпляру класса CommandsNextConfiguration. 
// Делается это ОБЯЗАТЕЛЬНО ПЕРЕД РЕГИСТРАЦИЕЙ КОМАНД
var commandsNextConfiguration = new CommandsNextConfiguration
{
  StringPrefixes = Settings.Prefixes,
  Services = services  // пихаем в инициализатор сбилженый ServiceCollection
};
[23:14]
И самое классное.

Принцип распространения зависимостей работает и в пределах ServiceCollection!

Т.е.... 
Рассмотрим пример.

Командные модули у тебя работают с БД. Рассмотрим абстрактный CommandModule.
Ты вынес всю логику взаимодействия с БД в класс DbProvider. 
И именно DbProvider у тебя работает с DbContext.

Т.е. получается такая цепочка:
DbContet -> DbProvider -> CommandModule

Если с CommandModule ещё понятно, откуда она будет черпать зависимости (ты же ткнул либу DSharpPlus в коллекцию). Но ведь DbProvider и DbContext лежат в одном ServiceCollection. Как они узнают друг о друге?
А спокойно. 

services = new ServiceCollection()
  .AddSingleton<DbContext>()
  .AddSingleton<DbProvider>()
  .BuildServiceCollection();

ВСЁ. 
Сперва в коллекцию загрузится DbContext
Потом будет подгружаться DbProvider. ServiceProvider такой "Ага! А ему надо DbContext! А у меня уже есть такой!". И всё спокойно передаст.

Но отсюда вытекает важный момент: очень важен порядок добавления зависимостей в ServiceCollection!!!

// ТАК НЕ СРАБОТАЕТ
// Важен порядок добавления зависимостей
services = new ServiceCollection()
  .AddSingleton<DbProvider>()
  .AddSingleton<DbContext>()
  .BuildServiceCollection();
[23:16]
Что в итоге из этого вытекает:
Ты просто закидываешь нужные классы, которые нужно распространить между другими, в общий котел под названием ServiceCollection.
А потом при создании нового модуля ты совсем не паришься о том, где и как там передать ссылку на необходимую зависимость. Просто в конструкторе класса указываешь, что "мне нужно это. дайте это". И всё. ServiceCollection как миленький тебе всё выдаст. (изменено)

Hlebushek — Сегодня, в 23:18
такой вопрос, откуда у меня конструктор класса dbProvider узнает откуда ему тащить класс DbContext, мы же не где не указали что нужно искать в коллекции нашей?

Flexlug — Сегодня, в 23:19
Обрати внимание, что нигде напрямую не вызывается DbProvider через ключевое слово new.
Т.е. ты не вызываешь конструктор сам.

Ты отдаешь всё это на откуп ServiceCollection.
А сам ServiceCollection уже знает о существовании DbContext

Hlebushek — Сегодня, в 23:21
т.е когда я кидаю свой класс в servicecollection то она сама при его создании в конструктор все передаст?

Flexlug — Сегодня, в 23:21
+++ (изменено)
[23:21]
Всё верно

Hlebushek — Сегодня, в 23:22
и такой вопрос, как мне тогда создать класс dbProvider, через new же не прокатит как я понимаю?

Flexlug — Сегодня, в 23:23
Тебе не надо его самому создавать.
ServiceCollection сама его создаст, если DbProvder где-то требуется (изменено)
[23:24]
Т.е. если ты в модуле команд укажешь в конструкторе, что ему нужен DbProvider, то ServiceCollection сама создаст экземпляр DbProvider и передаст его ему.
[23:24]
напоминаю, что сами командные модули регистрируются в отдельном месте (изменено)


Hlebushek — Сегодня, в 23:26
так, вопрос, если мне этот класс нужен где я и servicecollection собираю то как мне его получить? мне на уровень выше выносить инициализацию servicecollection нужно, а в текущий класс добавить конструктор с dbprovider аргументом? (изменено)

Hlebushek — Сегодня, в 23:35


Flexlug — Сегодня, в 23:35
а
[23:35]
не заметил
[23:37]
не понял вопроса
[23:37]
ща
[23:37]
так, вопрос, если мне этот класс...
какой класс?

Hlebushek — Сегодня, в 23:38
ну у меня есть класс bot в котором я собираю serviceCollection, и в этом же классе мне нужен dbProvider, как мне его достать из serviceCollection? (изменено)

Flexlug — Сегодня, в 23:40
var dbContext = services.GetRequiredService<DbContext>()
[23:40]
не могу не спросить
нахер тебе DbContext в классе Bot?

@Flexlug
не могу не спросить нахер тебе DbContext в классе Bot?

Hlebushek — Сегодня, в 23:41
я оберну это в dbProvider потом

Flexlug — Сегодня, в 23:41
окей

@Flexlug
var dbContext = services.GetRequiredService<DbContext>()

Hlebushek — Сегодня, в 23:42
правильно понимаю, таким образом могу получить нужный мне объект и при необходимости сервис сам его создаст? (изменено)

Flexlug — Сегодня, в 23:43
да

Hlebushek — Сегодня, в 23:43
огромное спасибо, теперь все встало на свои полочки 

Flexlug — Сегодня, в 23:43
Рад помочь)